Introduction to Go
Canberra Gophers Meeting
12 Aug 2014

Dave Cheney
dave@cheney.net
http://dave.cheney.net/
@davecheney

* Welcome

Thank you to Pablo Rozas-Larraondo for getting the meetup off the ground.

Thank you to our sponsor at CSIRO for the space.

Thank you those attending for taking the time to come out tonight. 

* Outline of this talk

The history of Go project

Overview of the language

Overview of the tools

Possibly some questions

* History of the Go project

* Origins of Go

Project started in 2007 by Rob Pike, Robert Griesemer, Ken Thompson

Russ Cox and Ian Lance Taylor joined soon after

There is a story that Go was designed while waiting for a C++ program to compile. This is at best only partly true.

* Origins of Go, continued

In reality Go was a response to the many of the factors that Rob, Robert and Ken experienced at the time with the languages in use at Google; C++, Java, and Python.

Rob Pike's 2012 paper, [[http://commandcenter.blogspot.com.au/2012/06/less-is-exponentially-more.html][Less is exponentially more]] gives an excellent overview of the environment that gave rise to Go.

* Public announcement

First public announcement November, 2009. [[https://www.youtube.com/watch?v=rKnDgT73v8s][The Go Programming Language, 2009]]

.image introduction-to-go/pike-2009.png

* Open source

Go is an open source project.

All the commits, code review, design are done in the open on a public mailing lists.

The only qualifications for contributing to the project is free time.

* 2009 - 2012

Rapid iteration over the next 2.5 years

[[http://blog.golang.org/go-version-1-is-released][Go 1.0 was released]] on the 28th of March, 2012.

Go 1.0 marked a line in the sand

- API stability [[http://golang.org/doc/go1compat][The Go 1 compatability document]]

- No major language changes (there have been a few minor additions)

- [[http://blog.golang.org/the-path-to-go-1][The path to Go 1]]

* 2012 - now

3 point releases so far; Go 1.1, 1.2, and 1.3.

The fourth, Go 1.4, is on target to ship in December.

Rough 6 month release cycle

- 3 month change window, 3 month stabalisation.
- Big ticket features are discussed before the change window opens.

Each release has bought incremental improvements in the compilers, the runtime, the garbage collector.

New platforms and new architectures added.

Stable - the bar for adding a new feature is insurmountably high.

- link to r's Gophercon 2014 talk, http://talks.golang.org/2014/hellogophers.slide

* Language Overview

- The efficiency of a statically-typed compiled langauge with the ease of programming of a dynamically typed language.

- expand on this

* Good support for concurrency and communication

- Multicore is a reality, multiprocessing is not a solution

* Safety

- Typed, and type safe

	

- Array accesses are bounds checked

	s := make([]string, 10)

	for i := 0; i <= 10; i++ {
		// oops
	}

- All memory is zeroed if not explicitly initialised

	var q int	// initalised to 0
	var f = 7	// initalised to 7, type defaults to int

* Safety, continued

- Pointers, but no pointer arythmetic

	var x = 1000
	var y = &x
	y += 4		// nope

- No implicit conversions; booleans and integers are not aliases

	i := 2
	if i { ... }	// nope
	if i != 0 { ... }

* Garbage collected

* Speed

Go is often quoted for its fast compilation, but this is only one fascet of the idea of Go being a _fast_ language to program in.

- False dycotomy of static languages being "slow and painful" and dynamic langauges being "fast and fun"

Specifically to address the issues

- "Fixing it by adding more software isn't going to do it" -[[http://youtu.be/rKnDgT73v8s?t=7m][Rob Pike, Nov 2009]]

- Variant of the C clurly brace family -- Steve Yegge 'the next big language'

* Opinioned

- Unused variables are an error

- Unused imports are also an error

- The compiler does not issue warnings, only errors.

- A single expected way to format code as defined by `go fmt` (more on this later)

* Modular, incremental, compilation, which we call packages.

- Unit of compilation is the package, not the file

- Unit of importing is the package, not a type

* Simple syntax

25 keywords

	break        default      func         interface    select
	case         defer        go           map          struct
	chan         else         goto         package      switch
	const        fallthrough  if           range        type
	continue     for          import       return       var

-- regular, orthogonal concepts
-- show anon funcs, types, structs

- Focus on readable code, to the point of being boring -- but it is regular, all Go code looks the same, very easy to work with other's code (assuming it is sane), very easy to spot insane code.

* Arrays, slices and mapsA

* Types, but not subtypes

- Real structs
-- pointers when you need them, but no pointer arithmetic


* Functions, methods

- Multiple return values the norm

- methods may be attached to _any_ type that you declare

* Errors, not exceptions

- 

* Packages

- explicit dependencies, import "fmt", then _fmt_'s symbols are referened by fmt. prefix.


* Language implementation

* Small, well polished standard library

- The usual libc/libm cast of characters

- Support for networking, http, tls 

- Support for common encoding, xml, json

- Support for compression

To a first order aproximation, the std lib provides only the things needed to build Go itself.

Prior to Go 1.0 many packages were moved out of the standard library, or culled altogether.

* Excellent cross platform support

- Windows, OS X, Linux, {Free,Open,Net,DragonFly}BSD, Solaris

- NaCl, Google's Native Client runtime

- Experimental support for writing some class of Android application coming soon.

* Excellent cross platform support, continued

Cross platform is defined as the superset of all platforms with some not supporting a feature, rather than the lowest common denominator

- Tooling supports a simple conditional compilation model to cope with various platform differences (more on that later)

* Excellent cross architecture support

- gc toolchain supports arm, amd64 and i386. Support for powerpc64 in the works

- gccgo toolchain supports all of the abovei, and more, like MIPS.

- Garbage collected

- Built in maps / slices

- First class functions, closures and lambdas.

* Tools

`/usr/bin/go`

Simple, zero configuration build tool

- conditional compilation via suffixes, and build tags

* $GOPATH

- cross compilation and conditional compilation.

- go vet, no warnings

- godoc

- go fmt

- go test

- go cover

- go race

- go/{ast,parser,printer} packages enabling 

- oracle

- cgo

* Performance

Depending on your requirements; good to excellent

Varies by architecture; amd64 is the poster child due to its ubiquity

All platforms have improved overtime

* Go 1.0 vs tip (Go 1.4)

.image introduction-to-go/go1-vs-tip.png

* Application

- cross compilation

- static tools

Go appears to be attractive to the scientific and bioinformatic communities, displacing their use of scipy/numpy. Scientists appear to be a pragmatic bunch and I like to think that Go is a language that helps them get stuff done.
The static binary story is very refreshing, considering the previous decade’s focus on managed runtimes and dynamic languages, both of which have a complex and unwieldy distribution story. This appears to be very attractive to system administrators and others who identify with the ‘devops’ moniker.
In this space we see projects like Docker and Hashicorp’s stable of tools like Consul, Serf, and the recently released Terraform, leading the charge.
One of the unexpected successes of Go is its applicability for programmers producing cross platform CLI tools, previously a domain of C and operating system distributions.
I personally would like to see less of a reliance on cgo, and hope that over time the goal of “Pure Go” becomes an aspirational catch cry just as it did with Java (does anyone remember type 2 JDBC drivers ? yuk).
Another recent surprise is the experimental support for Go on Android that David Crawshaw is working on for the 1.4 release.
Lastly, I think the potential of Go as a language to teach the art and the profession of programming is enormous.

* How to get started

Start with the tour, [[https://tour.golang.org][tour.golang.org]]

Read [[http://golang.org/doc/effective_go.html][Effective Go]]

Online communities

- [[http://reddit.com/r/golang][reddit.com/r/golang]]

- [[https://groups.google.com/forum/#!forum/golang-nuts][golang-nuts mailing list]]

- [[https://plus.google.com/communities/114112804251407510571][Go+ on G+]]

* Questions

This talk is online

[[talks.godoc.org/github.com/davecheney/canberra-gophers/introduction-to-go.slide][talks.godoc.org/github.com/davecheney/canberra-gophers/introduction-to-go.slide]]

All the links inside the talk are clickable, I encourage you to follow them.
