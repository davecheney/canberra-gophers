Introduction to Go
Canberra Gophers Meeting
12 Aug 2014

Dave Cheney
dave@cheney.net
http://dave.cheney.net/
@davecheney

* Welcome

Thank you to Pablo Rozas-Larraondo for getting the meetup off the ground.

Thank you to our sponsor at CSIRO for the space.

Thank you those attending for taking the time to come out tonight. 

* Who am I

Programming grunt from Sydney, Australia.

Passionate about all things Go since 2010.

Co-organiser of the Sydney Go Users group along with Andrew Gerrand.

* Outline of this talk

- The history of Go project

- Overview of the language

- Overview of the tools

- Possibly some questions

* History of the Go project

* Origins of Go

Go started in 2007 by Rob Pike, Robert Griesemer, Ken Thompson.

Russ Cox and Ian Lance Taylor joined soon after.

There is a story that Go was designed while waiting for a C++ program to compile.

* Origins of Go, continued

In reality Go was a response to the many of the factors that Rob, Robert and Ken experienced at the time with the languages in use at Google; C++, Java, and Python.

Rob Pike's 2012 paper, [[http://commandcenter.blogspot.com.au/2012/06/less-is-exponentially-more.html][Less is exponentially more]] gives an excellent overview of the environment that gave rise to Go.

* Public announcement

First public announcement November 10th, 2009. [[https://www.youtube.com/watch?v=rKnDgT73v8s][The Go Programming Language, 2009]]

.image introduction-to-go/pike-2009.png

* Open source

Go is an open source project.

All the commits, code review, design, debate, etc, are done in the open on a public mailing lists.

The only qualification for [[http://golang.org/doc/contribute.html][contributing]] to the project is free time.

* 2009 - 2012

Rapid iteration over the next 2.5 years

[[http://blog.golang.org/go-version-1-is-released][Go 1.0 was released]] on the 28th of March, 2012.

Go 1.0 marked a line in the sand

- API stability. [[http://golang.org/doc/go1compat][The Go 1 compatability document]]

- No major language changes (there have been a few minor additions)

- [[http://blog.golang.org/the-path-to-go-1][The path to Go 1]]

* 2012 - now

3 point releases so far; Go 1.1, 1.2, and 1.3.

The fourth, Go 1.4, is on target to ship in December.

Rough 6 month release cycle

- 3 month change window, 3 month stabalisation.

- Big ticket features are discussed before the change window opens.

Each release has bought incremental improvements in the compilers, the runtime, the garbage collector.

New platforms and new architectures added.

* Stablity

Pro:

- The language is guarenteed to be stable for the lifetime of Go 1.

- We assert this on every commit.

- Your code you write today will continue to compile under any newer version of Go 1.

Con:

- The bar for adding a new feature is now insurmountably high.

* Language Overview

* Safety

Typed, and type safe

	var i int = -1
	var u uint = 200

	i = u	// nope

	if i > u { ... }	// nope

Array accesses are bounds checked

	s := make([]string, 10)

	for i := 0; i <= 10; i++ {
		// oops
	}

No dangling pointers, return a stack value from a function with impunity.

- Language will move allocations to the stack if required.
- Escape analysis will move them back if not.

* Safety, continued

All memory is zeroed if not explicitly initialised

	var q int	// initalised to 0
	var f = 7	// initalised to 7, type defaults to int

Pointers, but no pointer arythmetic

	var x = 1000
	var y = &x
	y += 4		// nope

No implicit conversions; booleans and integers are not aliases

	i := 2
	if i { ... }	// nope
	if i != 0 { ... }

* Good support for concurrency and communication

- Multicore is a reality

- Multiprocessing is not a solution

* Garbage collected

Enables concurrency, eliminates the bookkeeping errors related to ownership of shared values.

Elimitates an entire class of use after free and memory leak bugs.

Performance is good and getting better every release, plans are afoot for a new concurrent compacting collector in the next 12 months.

- In the cases that I have investigated where reporters were blaming the garbage collector for poor performance, the underlying cause was their allocation rate was unsustainable.

* Speed

Go is often quoted for its fast compilation, but this is only one fascet of the idea of Go being a _fast_ language to program in.

- False dycotomy of static languages being "slow and painful" and dynamic langauges being "fast and fun"

"Clumsy type systems drive people to dynamically typed languages" -Robert Griesemer

Specifically to address the issues

- "Fixing it by adding more software isn't going to do it" -[[http://youtu.be/rKnDgT73v8s?t=7m][Rob Pike, Nov 2009]]

- Variant of the C clurly brace family -- Steve Yegge 'the next big language'

* Opinioned

- Unused variables are an error.

- Unused imports are also an error.

- The compiler does not issue warnings, only errors.

- A single way to format code as defined by `go fmt` (more on this later)

* Modular, incremental, compilation, which we call packages.

- Unit of compilation is the package, not the file.

- Unit of importing is the package, not a type, or a symbol.

* Whirlwind language tour

* Constants

Constants come in various kinds, but are by default untyped. 

Constant strings, bools, integers, floats, complex numbers.

Untyped constants operate with arbitrary precision.

.code introduction-to-go/precision.go /START OMIT/,/END OMIT/

* Types

The usual suspects

- signed integers, `int8`, `int16`, `int32`, `int64`

- unsigned integers, `uint8`, `uint6`, `uint32`, `uint64`

- aliases, `byte`, `rune`, `int`, `uint`

- booleans, `bool`

- strings, `string`

- IEEE floating point, `float32`, `float64`

- Complex type, `complex128`

* Variables

There are several ways to declare a variable in Go

	// all three vriables are of type int
	var y = 100
	var x int	// x == 0

Short variable declaration

	s := 100	

Leads to type inference

	f, err := os.Open("/etc/motd")

- `f` is a `*os.File` type
- `err` is an `error` type interface

* Expressions and Statements

Expressions are taken mostly from C.

Statements are _not_ Expressions.

	y = x++	// nope		

	if x = 1 { ... } // nope

* Arrays and Slices

Arrays are fixed sized typed vectors.

Different sized arrays are different types.

	var buf [100]byte	// an array of 100 bytes
	var buf2 [20]byte	// an array of 20 bytes

	buf = buf2	// nope

Slices are dynamically typed vectors.

	var buf []byte
	var buf2 []byte

	buf = make([]byte, 20)
	buf2 = buf

Both arrays and slices have a length, one is determined at compile time, the other at runtime.

* Arrays and Slices, continued

You can slice an array to produce a slice

	var buf [100]byte
	var b = buf[:10]	

`b` is a slice which contains a reference to the underlying array, `buf`.

* Maps

Maps are a typed 
	
	var m map[string]int

* Structs

Structs are composite types

	type S struct {
		A int
		B bool
		c string
	}

There is no analog for `C` 's union type, it is fundamentally unsafe.

* Literals

Array literal

	var a = [4]int { 1, 3, 5, 7 }
	var b = [...]int { 7, 7, 7 }	// b is of type [3]int

Slice literal

	var s = []string{ "alpha", "beta", "gamma" }
	
Map literal

	var m = map[string]bool { "Java": false, "Ruby": false, "Go": true }

* Pointers

* Control flow

`if`

	if a > b & c { ... }

`for`

	var numbers []int

	for i := 0; i < len(numbers); i++ { ... }

	for 

`for` `range`

	for i, num := range numbers { ... }

* Control flow, continue

`switch`

	var s string
	switch s {
	case "dave":
		...
	case "andrew", "pablo":
		...
	default:
		...
	}

* Control flow, continue

Labeled `break`

	done:
	for x := range y {
		for k, v := range x {
			if k == "dave" {
				fmt.Println(v)
				break done
			}
		}
	}	

Also a `goto`

* Functions

- Multiple return values the norm

* Methods

- methods may be attached to _any_ type that you declare

- no constructor or destructor

- use New

- discuss, var p = Point{3,4} vs p = &Point{3,4}


* Errors, not exceptions

Leverage multiple return values and a convention

Go has `panic` and `recover`, but they are not the same as exceptoins.

"Errors are just values" -Rob Pike, Gophercon 2014

[[http://blog.golang.org/error-handling-and-go][Error handling and Go]]

* Interfaces

Eschew _is_a_ in favor of _has_a_.

Anything which declares the appropriate method set implements that interface automatically.

.code introduction-to-go/parallelogram.go /START1 OMIT/,/END1 OMIT/

* Interfaces, continued

.play introduction-to-go/parallelogram.go /START2 OMIT/,/END2 OMIT/

* Interfaces, continued

`io.Writer`

	type Writer interface {
		Write(p []byte) (n int, err error)
	}

From the `fmt` package.

	func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)

Here are some types that implment `io.Writer`

	*bufio.Writer
	*bytes.Buffer
	net.Conn
	*os.File

* Packages

Packages define modules 

Explicit dependencies, import "fmt", then _fmt_ 's symbols are referenced by the `fmt.` prefix.

	import "fmt"

	func main() {
		fmt.Printf("Hello %s\n", "world)
	}

Packages enabled incremental compilation and 

Packages are also key to the initalisation semantics

Circular dependencies are not allowed

- If you are running into issues of circular imports in your program, you may have overused packages.

* Reflection

The `reflect` package and the empty interface, `interface{}` provide Go with its introspection capabilities.

[[http://blog.golang.org/laws-of-reflection][The Laws of Reflection]]

* Goroutines

- Thread per connection logic without the overhead of a thread

- go

- select

- send

- receive

* Language implementation

* Small, well polished standard library

- The usual libc/libm cast of characters

- Support for networking, http, TLS 

- Support for common encodings, XML, JSON

- Support for compression

To a first order aproximation, the std lib provides only the things needed to build Go itself.

Prior to Go 1.0 many packages were moved out of the standard library, or culled altogether.

* Excellent cross platform support

- Windows, OS X, Linux, {Free,Open,Net,DragonFly}BSD, Solaris

- NaCl, Google's Native Client runtime

- Experimental support for writing some class of Android application coming soon.

Cross platform is defined as the superset of all platforms with some not supporting a feature, rather than the lowest common denominator

* Excellent cross architecture support

gc toolchain supports arm, amd64 and i386. Support for powerpc64 in the works.

gccgo toolchain supports all of the abovei, and more, like MIPS.

* Tools

`/usr/bin/go`

Simple, zero configuration build tool.

Supports conditional compilation via suffixes, and build tags.

- Tooling supports a simple conditional compilation model to cope with various platform differences (more on that later)

Support for cross compilation.

* $GOPATH

- go vet, no warnings

- godoc

- go fmt

- go test

- go cover

- go race

- go/{ast,parser,printer} packages enabling 

- oracle

- cgo

* Performance

Depending on your requirements; good to excellent

Varies by architecture; amd64 is the poster child due to its ubiquity

All platforms have improved overtime

* Go 1.0 vs tip (Go 1.4)

.image introduction-to-go/go1-vs-tip.png _ 580

* How to get started

Start with the tour, [[https://tour.golang.org][tour.golang.org]]

Read [[http://golang.org/doc/effective_go.html][Effective Go]]

Online communities

- [[http://reddit.com/r/golang][reddit.com/r/golang]]

- [[https://groups.google.com/forum/#!forum/golang-nuts][golang-nuts mailing list]]

- [[https://plus.google.com/communities/114112804251407510571][Go+ on G+]]

* Questions

This talk is online

[[talks.godoc.org/github.com/davecheney/canberra-gophers/introduction-to-go.slide][talks.godoc.org/github.com/davecheney/canberra-gophers/introduction-to-go.slide]]

All the links inside the talk are clickable, I encourage you to follow them.

Also, please take the time to visit

- Rob Pike's [[http://talks.golang.org/2014/hellogophers.slide][Gophercon 2014 Keynote]]

- Francesc Campoy Flores' [[http://talks.golang.org/2013/go4python.slide][Go for Pythonistas]] and [[http://talks.golang.org/2014/go4java.slide][Go for JavaÃ¯stes]]

