Introduction to Go
Canberra Gophers Meeting
12 Aug 2014

Dave Cheney
dave@cheney.net
http://dave.cheney.net/
@davecheney

* Welcome

Thank you to Pablo Rozas-Larraondo for getting the meetup off the ground.

Thank you to our sponsor at CSIRO for the space.

Thank you those attending for taking the time to come out tonight. 

* Who am I

Programming grunt from Sydney, Australia.

Passionate about all things Go since 2010.

Co-organiser of the Sydney Go Users group along with Andrew Gerrand.

* Outline of this talk

The history of Go project

Overview of the language

Overview of the tools

Possibly some questions

* History of the Go project

* Origins of Go

Project started in 2007 by Rob Pike, Robert Griesemer, Ken Thompson

Russ Cox and Ian Lance Taylor joined soon after

There is a story that Go was designed while waiting for a C++ program to compile. This is at best only partly true.

* Origins of Go, continued

In reality Go was a response to the many of the factors that Rob, Robert and Ken experienced at the time with the languages in use at Google; C++, Java, and Python.

Rob Pike's 2012 paper, [[http://commandcenter.blogspot.com.au/2012/06/less-is-exponentially-more.html][Less is exponentially more]] gives an excellent overview of the environment that gave rise to Go.

* Public announcement

First public announcement November 10th, 2009. [[https://www.youtube.com/watch?v=rKnDgT73v8s][The Go Programming Language, 2009]]

.image introduction-to-go/pike-2009.png

* Open source

Go is an open source project.

All the commits, code review, design are done in the open on a public mailing lists.

The only qualification for [[http://golang.org/doc/contribute.html][contributing]] to the project is free time.

* 2009 - 2012

Rapid iteration over the next 2.5 years

[[http://blog.golang.org/go-version-1-is-released][Go 1.0 was released]] on the 28th of March, 2012.

Go 1.0 marked a line in the sand

- API stability [[http://golang.org/doc/go1compat][The Go 1 compatability document]]

- No major language changes (there have been a few minor additions)

- [[http://blog.golang.org/the-path-to-go-1][The path to Go 1]]

* 2012 - now

3 point releases so far; Go 1.1, 1.2, and 1.3.

The fourth, Go 1.4, is on target to ship in December.

Rough 6 month release cycle

- 3 month change window, 3 month stabalisation.

- Big ticket features are discussed before the change window opens.

Each release has bought incremental improvements in the compilers, the runtime, the garbage collector.

New platforms and new architectures added.

* Stable 

Pro:

- The language is guarenteed to be stable for the lifetime of Go 1.

- We assert this on every commit.

- Your code you write today will continue to compile under any newer version of Go.

Con:

- The bar for adding a new feature is now insurmountably high.

* Language Overview

- The efficiency of a statically-typed compiled langauge with the ease of programming of a dynamically typed language.

- expand on this

* Safety

- Typed, and type safe

	var i int = -1
	var u uint = 200

	i = u	// nope

	if i > u { ... }	// nope

- Array accesses are bounds checked

	s := make([]string, 10)

	for i := 0; i <= 10; i++ {
		// oops
	}

- no dangling pointers, return a stack value from a function with impunity

* Safety, continued

- All memory is zeroed if not explicitly initialised

	var q int	// initalised to 0
	var f = 7	// initalised to 7, type defaults to int

- Pointers, but no pointer arythmetic

	var x = 1000
	var y = &x
	y += 4		// nope

- No implicit conversions; booleans and integers are not aliases

	i := 2
	if i { ... }	// nope
	if i != 0 { ... }

* Good support for concurrency and communication

- Multicore is a reality

- Multiprocessing is not a solution

* Garbage collected

- not optional (see below, an opinionated language)

- enables concurrency, eliminates the bookkeeping errors related to ownership of shared values.

- elimitates an entire class of use after free and memory leak bugs 

- performance is good and getting better every release, plans are afoot for a new concurrent compacting collector in the next 12 months.

- in the cases that I have investigated where reporters were blaming the garbage collector for poor performance, these were always cases where their allocation rate was unsustainable.

* Speed

Go is often quoted for its fast compilation, but this is only one fascet of the idea of Go being a _fast_ language to program in.

- False dycotomy of static languages being "slow and painful" and dynamic langauges being "fast and fun"

"Clumsy type systems drive people to dynamically typed languages" -Robert Griesemer

Specifically to address the issues

- "Fixing it by adding more software isn't going to do it" -[[http://youtu.be/rKnDgT73v8s?t=7m][Rob Pike, Nov 2009]]

- Variant of the C clurly brace family -- Steve Yegge 'the next big language'

* Opinioned

- Unused variables are an error

- Unused imports are also an error

- The compiler does not issue warnings, only errors.

- A single expected way to format code as defined by `go fmt` (more on this later)

* Modular, incremental, compilation, which we call packages.

- Unit of compilation is the package, not the file

- Unit of importing is the package, not a type

* Simple syntax

25 keywords

	break        default      func         interface    select
	case         defer        go           map          struct
	chan         else         goto         package      switch
	const        fallthrough  if           range        type
	continue     for          import       return       var

-- regular, orthogonal concepts
-- show anon funcs, types, structs

- Focus on readable code, to the point of being boring -- but it is regular, all Go code looks the same, very easy to work with other's code (assuming it is sane), very easy to spot insane code.

* Constants

- constant types, strings, bools, integers, floats, complex

- arbitrary precision

.code introduction-to-go/precision.go /START OMIT/,/END OMIT/

* Variables

* Expressions

* Statements

- Statements are _not_ Expressions

	if x = 1 { ... } // nope
	if x = 1; x == 1 { ... } // yes

	y = x++	// nope		

* Arrays, slices and maps

Arrays, typed vectors

	var buf [100]byte	// an array of 100 bytes
	var buf2 [20]byte	// an array of 20 bytes

	buf = buf2	// nope

Slices

	var buf []byte
	var buf2 []byte

	buf = make([]byte, 20)
	buf2 = buf

* Arrays, slices and maps, continued

Maps
	
	var m map[string]int

* Literals

Array literal

	var a = [4]int { 1, 3, 5, 7 }
	var b = [...]int { 7, 7, 7 }	// b is of type [3]int

Slice literal

	var s = []string{ "alpha", "beta", "gamma" }
	
Map literal

	var m = map[string]bool { "Java": false, "Ruby": false, "Go": true }

* Short variable declaration

There are several ways to declare a variable in Go

	// all three vriables are of type int
	s := 100	
	var y = 100
	var x int	// x == 0

Leads to type inference

	f, err := os.Open("/etc/motd")

- `f` is a `*os.File` type
- `err` is an `error` type interface

* Types, but not subtypes

* Pointers

- Real structs
-- pointers when you need them, but no pointer arithmetic

* Control flow

- if

- for

- switch

* Control flow, continue

Labeled `break`

	done:
	for x := range y {
		for k, v := range x {
			if k == "dave" {
				fmt.Println(v)
				break done
			}
		}
	}	

Also a `goto`

* Functions

- Multiple return values the norm

* Methods

- methods may be attached to _any_ type that you declare

- no constructor or destructor

- use New

- discuss, var p = Point{3,4} vs p = &Point{3,4}


* Errors, not exceptions

- leverage multiple return values and a convention

- "Errors are just values" -Rob Pike, Gophercon 2014


* Interfaces

Eschew _is_a_ in favor of _has_a_.

Anything which declares the appropriate method set implements that interface automatically.

.code introduction-to-go/parallelogram.go /START1 OMIT/,/END1 OMIT/

* Interfaces, continued

.play introduction-to-go/parallelogram.go /START2 OMIT/,/END2 OMIT/

* Interfaces, continued

`io.Writer`

	type Writer interface {
        	Write(p []byte) (n int, err error)
	}

From the `fmt` pacakge.

	func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)

Here are some types that implment `io.Writer`

	bufio.NewWriter
	bytes.Buffer
	net.Conn
	*os.File

* Packages

explicit dependencies, import "fmt", then _fmt_'s symbols are referened by fmt. prefix.

	import "fmt"

	func main() {
		fmt.Printf("Hello %s\n", "world)
	}

Packages enabled incremental compilation and 

* Reflection

[[http://blog.golang.org/laws-of-reflection][The Laws of Reflection]]

* Goroutines

- Thread per connection logic without the overhead of a thread

- go

- select

- send

- receive

* Language implementation

* Small, well polished standard library

- The usual libc/libm cast of characters

- Support for networking, http, tls 

- Support for common encoding, xml, json

- Support for compression

To a first order aproximation, the std lib provides only the things needed to build Go itself.

Prior to Go 1.0 many packages were moved out of the standard library, or culled altogether.

* Excellent cross platform support

- Windows, OS X, Linux, {Free,Open,Net,DragonFly}BSD, Solaris

- NaCl, Google's Native Client runtime

- Experimental support for writing some class of Android application coming soon.

* Excellent cross platform support, continued

Cross platform is defined as the superset of all platforms with some not supporting a feature, rather than the lowest common denominator

- Tooling supports a simple conditional compilation model to cope with various platform differences (more on that later)

* Excellent cross architecture support

- gc toolchain supports arm, amd64 and i386. Support for powerpc64 in the works

- gccgo toolchain supports all of the abovei, and more, like MIPS.

- Garbage collected

- Built in maps / slices

- First class functions, closures and lambdas.

* Tools

`/usr/bin/go`

Simple, zero configuration build tool

- conditional compilation via suffixes, and build tags

* $GOPATH

- cross compilation and conditional compilation.

- go vet, no warnings

- godoc

- go fmt

- go test

- go cover

- go race

- go/{ast,parser,printer} packages enabling 

- oracle

- cgo

* Performance

- Depending on your requirements; good to excellent

- Varies by architecture; amd64 is the poster child due to its ubiquity

- All platforms have improved overtime

* Go 1.0 vs tip (Go 1.4)

.image introduction-to-go/go1-vs-tip.png

* Application

- cross compilation
One of the unexpected successes of Go is its applicability for programmers producing cross platform CLI tools, previously a domain of C and operating system distributions.

- static tools

Go appears to be attractive to the scientific and bioinformatic communities, displacing their use of scipy/numpy. Scientists appear to be a pragmatic bunch and I like to think that Go is a language that helps them get stuff done.

The static binary story is very refreshing, considering the previous decade’s focus on managed runtimes and dynamic languages, both of which have a complex and unwieldy distribution story. This appears to be very attractive to system administrators and others who identify with the ‘devops’ moniker.

In this space we see projects like Docker and Hashicorp’s stable of tools like Consul, Serf, and the recently released Terraform, leading the charge.

Another recent surprise is the experimental support for Go on Android that David Crawshaw is working on for the 1.4 release.

Lastly, I think the potential of Go as a language to teach the art and the profession of programming is enormous.

* How to get started

Start with the tour, [[https://tour.golang.org][tour.golang.org]]

Read [[http://golang.org/doc/effective_go.html][Effective Go]]

Online communities

- [[http://reddit.com/r/golang][reddit.com/r/golang]]

- [[https://groups.google.com/forum/#!forum/golang-nuts][golang-nuts mailing list]]

- [[https://plus.google.com/communities/114112804251407510571][Go+ on G+]]

* Questions

This talk is online

[[talks.godoc.org/github.com/davecheney/canberra-gophers/introduction-to-go.slide][talks.godoc.org/github.com/davecheney/canberra-gophers/introduction-to-go.slide]]

All the links inside the talk are clickable, I encourage you to follow them.

Also, please take the time to visit

- Rob Pike's [[http://talks.golang.org/2014/hellogophers.slide][Gophercon 2014 Keynote]]

- Francesc Campoy Flores' [[http://talks.golang.org/2013/go4python.slide][Go for Pythonistas]] and [[http://talks.golang.org/2014/go4java.slide][Go for Javaïstes]]

